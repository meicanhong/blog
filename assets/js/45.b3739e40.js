(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{484:function(e,t,n){"use strict";n.r(t);var o=n(2),r=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("在线上环境碰到一张 mongo 表里有重复数据，最终追溯到了 node mongo 插入数据那里，发现了 mongo 的 upsert 并非是线程安全的，在并发的情况下会产生重复数据。后面查阅 monog 的文档，也指出了使用 upsert 方法时要给表加上唯一索引。")]),e._v(" "),t("blockquote",[t("h4",{attrs:{id:"upsert-with-unique-index"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#upsert-with-unique-index"}},[e._v("#")]),e._v(" Upsert with Unique Index")]),e._v(" "),t("p",[e._v("When using the "),t("a",{attrs:{href:"https://www.mongodb.com/docs/manual/reference/method/db.collection.update/#std-label-update-upsert",target:"_blank",rel:"noopener noreferrer"}},[e._v("upsert: true"),t("OutboundLink")],1),e._v(" option with the "),t("a",{attrs:{href:"https://www.mongodb.com/docs/manual/reference/method/db.collection.update/#mongodb-method-db.collection.update",target:"_blank",rel:"noopener noreferrer"}},[e._v("update()"),t("OutboundLink")],1),e._v(" method, "),t("strong",[e._v("and not")]),e._v(" using a "),t("a",{attrs:{href:"https://www.mongodb.com/docs/manual/core/index-unique/#std-label-index-type-unique",target:"_blank",rel:"noopener noreferrer"}},[e._v("unique index"),t("OutboundLink")],1),e._v(" on the query field(s), multiple instances of a "),t("a",{attrs:{href:"https://www.mongodb.com/docs/manual/reference/method/db.collection.update/#mongodb-method-db.collection.update",target:"_blank",rel:"noopener noreferrer"}},[e._v("update()"),t("OutboundLink")],1),e._v(" operation with similar query field(s) could result in duplicate documents being inserted in certain circumstances.")])]),e._v(" "),t("p",[e._v("我一般都是这样子创建唯一索引：\ndb.collection.createIndex(unique_keys, { backgroud : true,  unique : true})")]),e._v(" "),t("p",[e._v("这里也分析一下为啥 upsert 会产生重复数据吧。是因为 upsert 操作不是原子性的，upsert 分为俩步：")]),e._v(" "),t("ul",[t("li",[e._v("找数据")]),e._v(" "),t("li",[e._v("覆盖数据或插入数据")])]),e._v(" "),t("p",[e._v("在并发下，多个线程同时 upsert 并完成找数据这一步操作，此时这些线程都没有找到数据，然后都进行插入数据的操作，于是重复数据便产生了。解决这一问题的方案有俩种，一种是给表加唯一索引，另外一种是给 upsert 这俩部操作加上一个写锁。")]),e._v(" "),t("p",[e._v("总结\n以后用 mongo 时，尽量给每张表都加上唯一索引吧，有重复数据的时候还得先去重才能建索引，太麻烦了，不如一开始就建好唯一索引。")])])}),[],!1,null,null,null);t.default=r.exports}}]);